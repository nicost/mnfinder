import ij.IJ;
import ij.ImagePlus;
import ij.plugin.frame.RoiManager;
import ij.gui.Roi;
import ij.gui.PolygonRoi;
import java.util.Arrays;

import org.micromanager.projector.internal.ProjectorControlForm;
import org.micromanager.MultiStagePosition;
import org.micromanager.data.DataStore;

channelGroup = "Channel";
imagingChannel = "Cy5";
imagingExposure = 500;
conversionChannel = "Bleach";
conversionTimeMs = 1000;
afterConversionChannel = "Cherry";
afterConversionExposure = 500;

minSize = 25.0;
maxSize = 800.0;

fractionOfNucleiToBeConverted = 0.1;

// filename for measurements
outputFile = "E:\\\\Users\\Vale Lab\\Desktop\\nuclei.txt";

// filename for images, leave blank if you do not want to save images
imageFileName = "";

/** There usually is no need to edit below this line **/

// we will use MMCore multiple times, so get it here
core = mm.getCMMCore();

// open the Projector plugin
pcf = ProjectorControlForm.showSingleton(core, mm);

// the ImageJ roiManager	
roiManager = RoiManager.getInstance();
if (roiManager == null)
	roiManager = new RoiManager();

// get the current positionlist from Micro-Manager
pm = mm.getPositionListManager();
pl = pm.getPositionList();
positions = pl.getPositions();

// open the output file to write the measuerements to
outfile = new BufferedWriter(new FileWriter(outputFile));
outfile.write ("Site" + "\t" + "Pre-Post" + "\t" + "X" + "\t" + "Y" + "\t" + "Mean" + "\t" + "Int.Den");
outfile.newLine();

// create our own dataStore
store = mm.data().createRAMDatastore();
if (imageFileName.length() > 0) {
	store = mm.data().createMultipageTIFFDatastore(imageFileName, false, false);
}

dw = mm.getDisplayManager().createDisplay(store);
mm.getDisplayManager().manage(store);

// get a copy of the application's pipeline
blockingPipeline = true;
pipeLine = mm.data().copyApplicationPipeline(store, blockingPipeline);


int counter = 0;
for (position : positions) {
	MultiStagePosition.goToPosition(position, core);
	
	// snap an image, process and get it out as an ImageJ ImagePlus object
	mm.scripter().message("Snapping image #" + counter);
	core.setConfig(channelGroup, imagingChannel);
	core.setExposure(imagingExposure);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+counter+",c=0,z=0");
	img = imgList.get(0).copyAtCoords(coord);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();
	
	//dw.getImagePlus().setRoi(null); // make sure that there is no roi on the image
	//ip = dw.getImagePlus().duplicate();

	// get the nuclear masks 
	IJ.setAutoThreshold(ip, "Otsu Dark");
	IJ.run("Set Measurements...", "area centroid center bounding fit shape redirect=None decimal=2");
	
	IJ.run(ip, "Analyze Particles...", "size=" + minSize + "-" + maxSize + 
			" exclude clear add");

	// prepare the masks to be send to the DMD
	Roi[] allNuclei = roiManager.getRoisAsArray();
	Roi[] convertRois = new PolygonRoi[(int) (allNuclei.length * fractionOfNucleiToBeConverted) + 1];
	nrNucleiToSkip = (int) (1 / fractionOfNucleiToBeConverted);
	int convertCounter = 0;
	for (int i = 0; i < allNuclei.length; i += nrNucleiToSkip) {
		convertRois[convertCounter] = 
			new PolygonRoi(allNuclei[i].getConvexHull(), Roi.POLYGON);
		convertCounter++;
	}
	mm.scripter().message("Found " + convertCounter + " ROIs");

	// take and analyze the preconversion image
	core.setConfig(channelGroup, afterConversionChannel);
	core.setExposure(afterConversionExposure);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+counter+",c=1,z=0");
	img = imgList.get(0).copyAtCoords(coord);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();

	for (roi : allNuclei) {
		ip.setRoi(roi);
		stats = ip.getStatistics(ImagePlus.CENTROID + ImagePlus.MEAN + ImagePlus.INTEGRATED_DENSITY);
		mm.scripter().message("Mean: " + stats.mean );
		outfile.write("" + counter + "\t" + "Pre" + "\t" + stats.xCentroid + "\t" + stats.yCentroid + "\t" +
							stats.mean + "\t" + stats.INTEGRATED_DENSITY);
		outfile.newLine();
	}

	// convert the selected nuclei
	if (convertRois != null && convertRois.length > 0) {
		mm.scripter().message("Found " + convertRois.length + " ROIs");
		core.setConfig(channelGroup, conversionChannel);
		core.setExposure(conversionTimeMs);
		pcf.setROIs(convertRois);
		pcf.runRois();
		// use the snap function to expose for the desired amount of time
		mm.live().snap(true);
	}

	// re-image the now converted image and get the intensities of the converted nuclei
	core.setConfig(channelGroup, afterConversionChannel);
	core.setExposure(afterConversionExposure);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+counter+",c=2,z=0");
	img = imgList.get(0).copyAtCoords(coord);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();
	for (roi : convertRois) {
		ip.setRoi(roi);
		stats = ip.getStatistics(ImagePlus.CENTROID + ImagePlus.MEAN + ImagePlus.INTEGRATED_DENSITY);
		outfile.write("" + counter + "\t" + "Post" + "\t" + stats.xCentroid + "\t" + stats.yCentroid + "\t" +
							stats.mean + "\t" + stats.INTEGRATED_DENSITY);
		outfile.newLine();
		
		mm.scripter().message("Conv. Mean: " + stats.mean );
	}
	
	counter++;
}

store.freeze();

outfile.close();

mm.scripter().message("done!");



