
import ij.IJ;
import ij.ImagePlus;
import ij.plugin.frame.RoiManager;
import ij.gui.Roi;
import ij.gui.PolygonRoi;
import ij.gui.OvalRoi;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;


import org.micromanager.projector.internal.ProjectorControlForm;
import org.micromanager.MultiStagePosition;
import org.micromanager.data.DataStore;

import org.micromanager.internal.utils.NumberUtils;

channelGroup = "Channel";
imagingChannel = "Cy5";
imagingExposure = 250;
conversionChannel = "Bleach";
conversionTimeMs = 200;
afterConversionChannel = "Cherry";
afterConversionExposure = 50;

// sizes in square pixels
minSize = 300.0;
maxSize = 1800.0;

fractionOfNucleiToBeConverted = 0.1;

// skip images whose standard deviation or intensity is higher than this cutoff
//  Used to skip images that have edges in them.
maxStdDev = 12500.0;
maxMeanIntensity = 20000.0;

baseName = "Test20160812_0.5s";

// filename for measurements
outputFile = "E:\\\\Users\\Xiaowei\\"  + baseName + ".txt";

// filename for images, leave blank if you do not want to save images
//imageFileName = "E:\\\\Users\\Xiaowei\\" + baseName;
imageFileName = "";

/** There usually is no need to edit below this line 
____________________________________________________________*/


/** 
 * Utility function that reports intensities of rois in an image
 * 
 */
void reportIntensities(BufferedWriter theFile, int posCounter, ImagePlus ip, String label, Roi[] rois) {
	for (int i = 0; i < rois.length; i++) {
		ip.setRoi(rois[i]);
		stats = ip.getStatistics(ImagePlus.CENTROID + ImagePlus.MEAN + ImagePlus.INTEGRATED_DENSITY + ImagePlus.AREA);
		theFile.write("" + posCounter + "\t" + i + "\t" + label + "\t" + 
						NumberUtils.doubleToDisplayString(stats.xCentroid) + "\t" + 
						NumberUtils.doubleToDisplayString(stats.yCentroid) + "\t" +
						NumberUtils.doubleToDisplayString(stats.mean) + "\t"  + 
						NumberUtils.doubleToDisplayString(stats.area) );
		theFile.newLine();
	}
}

// we will use MMCore multiple times, so get it here
core = mm.getCMMCore();

// open the Projector plugin
pcf = ProjectorControlForm.showSingleton(core, mm);

// the ImageJ roiManager	
roiManager = RoiManager.getInstance();
if (roiManager == null)
	roiManager = new RoiManager();

// get the current positionlist from Micro-Manager
pm = mm.getPositionListManager();
pl = pm.getPositionList();
positions = pl.getPositions();

// open the output file to write the measuerements to
outfile = new BufferedWriter(new FileWriter(outputFile));
outfile.write ("Site" + "\t" + "ID" + "\t" + "Pre-Post-Status" + "\t" + "X" + "\t" + "Y" + "\t" + "Mean" + "\t" + "Area");
outfile.newLine();

// create our own dataStore
store = mm.data().createRAMDatastore();
if (imageFileName.length() > 0) {
	store = mm.data().createMultipageTIFFDatastore(imageFileName, false, false);
} 

Thread.sleep(1000);
dw = mm.getDisplayManager().createDisplay(store);
mm.getDisplayManager().manage(store);

// get a copy of the application's pipeline
blockingPipeline = true;
pipeLine = mm.data().copyApplicationPipeline(store, blockingPipeline);


int posCounter = 0;
for (position : positions) {
	MultiStagePosition.goToPosition(position, core);
	
	// snap an image, process and get it out as an ImageJ ImagePlus object
	mm.scripter().message("Snapping image #" + posCounter);
	core.setConfig(channelGroup, imagingChannel);
	core.setExposure(imagingExposure);
	core.waitForConfig(channelGroup, imagingChannel);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+posCounter+",c=0,z=0");
	metadata = imgList.get(0).getMetadata().copy().positionName(position.getLabel()).build();
	img = imgList.get(0).copyWith(coord, metadata);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();

	// check for edges by calculating stdev
	stat = ip.getStatistics();
	stdDev = stat.stdDev;
	mean = stat.mean;
	if (stdDev > maxStdDev || mean > maxMeanIntensity) {
		mm.scripter().message("Std. Dev. (" + stdDev + ") or intenisty (" + mean + ") too high, skipping this position");
	} else {
	
	//dw.getImagePlus().setRoi(null); // make sure that there is no roi on the image
	//ip = dw.getImagePlus().duplicate();

	// Pre-filter to improve nuclear detection and slightly enlarge the masks
	IJ.run(ip, "Smooth", "");
   IJ.run(ip, "Gaussian Blur...", "sigma=5.0");

	// get the nuclear masks 
	IJ.setAutoThreshold(ip, "Otsu dark");
	// Fill holes and watershed to split large nuclei
	IJ.run(ip, "Convert to Mask", "");
   IJ.run(ip, "Dilate", "");
   IJ.run(ip, "Erode", "");
   IJ.run(ip, "Watershed", "");

	// Now measure and store masks in ROI manager
	IJ.run("Set Measurements...", "area centroid center bounding fit shape redirect=None decimal=2");
	IJ.run(ip, "Analyze Particles...", "size=" + minSize + "-" + maxSize + 
			" pixel exclude clear add");

	// prepare the masks to be send to the DMD
	Roi[] allNuclei = roiManager.getRoisAsArray();
	mm.scripter().message("Found " + allNuclei.length + " nuclei");
	List convertRoiList = new ArrayList();
	List nonConvertRoiList = new ArrayList();
	nrNucleiToSkip = (int) (1 / fractionOfNucleiToBeConverted);
	int convertCounter = 0;
	for (int i = 0; i < allNuclei.length; i++) {
		// need to transform ROIs into ovalRois or they do not work with DMD
		rect = allNuclei[i].getBounds();
		nucRoi = new OvalRoi(rect.x, rect.y, rect.width, rect.height);
		if (i % nrNucleiToSkip == 0) {
			convertRoiList.add (nucRoi);
			convertCounter++;
		} else {
			nonConvertRoiList.add (nucRoi);
		}
	}
	convertRois = new OvalRoi[convertRoiList.size()];
	convertRois = convertRoiList.toArray(convertRois);
	roiManager.reset();
	for (Roi roi : convertRois)
		roiManager.addRoi(roi);
	nonConvertRois = new OvalRoi[nonConvertRoiList.size()];
	nonConvertRois = nonConvertRoiList.toArray(nonConvertRois);

	// take and analyze the preconversion image
	core.setConfig(channelGroup, afterConversionChannel);
	core.setExposure(afterConversionExposure);
	core.waitForConfig(channelGroup, afterConversionChannel);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+posCounter+",c=1,z=0");
	metadata = imgList.get(0).getMetadata().copy().positionName(position.getLabel()).build();
	img = imgList.get(0).copyWith(coord, metadata);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();

	// Report intensities of objects found
	reportIntensities(outfile, posCounter, ip, "Pre-Hit", convertRois);
	reportIntensities(outfile, posCounter, ip, "Pre-NoHit", nonConvertRois);

	// convert the selected nuclei
	if (convertRois != null && convertRois.length > 0) {
		mm.scripter().message("Will convert " + convertRois.length + " ROIs");
		core.setConfig(channelGroup, conversionChannel);
		core.setExposure(conversionTimeMs);
		core.waitForConfig(channelGroup, conversionChannel);
		pcf.setROIs(convertRois);
		// attempt to fix the disappearing MM_SLM window
		//Thread.sleep(100);
		pcf.runRois();
		// use the snap function to expose for the desired amount of time
		imgList = mm.acquisitions().snap();
		coord = mm.data().createCoords("t=0,p="+posCounter+",c=2,z=0");
		metadata = imgList.get(0).getMetadata().copy().positionName(position.getLabel()).build();
		img = imgList.get(0).copyWith(coord, metadata);
		pipeLine.insertImage(img);
	}

	// re-image the now converted image and get the intensities of the converted nuclei
	core.setConfig(channelGroup, afterConversionChannel);
	core.setExposure(afterConversionExposure);
	core.waitForConfig(channelGroup, afterConversionChannel);
	imgList = mm.acquisitions().snap();
	coord = mm.data().createCoords("t=0,p="+posCounter+",c=3,z=0");
	metadata = imgList.get(0).getMetadata().copy().positionName(position.getLabel()).build();
	img = imgList.get(0).copyWith(coord, metadata);
	pipeLine.insertImage(img);
	procImg = store.getImage(coord);
	iProcessor = mm.data().ij().createProcessor(procImg);
	ip = (new ImagePlus("tmp", iProcessor)).duplicate();
	
	// Report Intensities
	reportIntensities(outfile, posCounter, ip, "Post-Hit", convertRois);
	reportIntensities(outfile, posCounter, ip, "Post-NoHit", nonConvertRois);

	}
	posCounter++;
}

store.freeze();

outfile.close();

mm.scripter().message("done!");

