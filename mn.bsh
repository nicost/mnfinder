/**
 * Beanshell script to find micronuclei in a field of cells stained with a DNA dye
 * This script prefilters the image, automatically segments it, and find objects
 * of a certain size (size limits are set just under here)
 * 
 * Nico Stuurman, 2015, copyright regents of the University of California
 * 
 * 
 */

import java.util.ArrayList;
import java.awt.geom.Point2D;
import java.awt.Polygon;

import ij.IJ;
import ij.plugin.filter.GaussianBlur;
import ij.plugin.frame.RoiManager;
import ij.gui.ROI;

import org.micromanager.MMStudio;

import edu.valelab.gaussianfit.FitAllThread;
import edu.valelab.gaussianfit.algorithm.FindLocalMaxima;
import edu.valelab.gaussianfit.data.GaussianInfo;


// microNuclei allowed sizes
mnMinSize = 1.0;
mnMaxSize = 40.0;
// nuclei allowed sized
nMinSize = 125;
nMaxSize = 600;
// max distance a micronucleus can be separated from a nucleus
maxDistance = 30; 
// min distance a micronucleus should be from the edge of the image
minEdgeDistance = 3.0; // in microns



/**
 * calculates distance between two points
 */
distance(Point2D.Double p1, Point2D.Double p2) {
	x = p1.x - p2.x;
	y = p1.y - p2.y;
	total = x * x + y * y;
	return Math.sqrt(total);	
}

/**
 * Find the closest point in the Arraylist
 * for now, uses brute force search
 */
closest(Point2D.Double p, ArrayList l) {
	if (l.size() == 0) {
		return null;
	}
	closestNucleus = l.get(0);
	d = distance(p, closestNucleus);
	for (p2 : l) {
		dNew = distance(p, p2);
		if (dNew < d) {
			d = dNew;
			closestNucleus = p2; 
		}
	}
	return closestNucleus;
}


// start of the main code
microNuclei = new ArrayList();
nuclei = new ArrayList();

imp = IJ.getImage();
cal = imp.getCalibration();
width = imp.getProcessor().getWidth();
height = imp.getProcessor().getHeight();
widthUm = cal.getX(width);
heightUm = cal.getY(height);
pixelSize = cal.getX(1.0);

gui = MMStudio.getInstance();

// find just the nuclei
nucleiImp = imp.duplicate();
IJ.setAutoThreshold(nucleiImp, "Otsu dark");
Prefs.blackBackground = true;
IJ.run(nucleiImp, "Convert to Mask", "");
IJ.run(nucleiImp, "Erode", "");
IJ.run(nucleiImp, "Erode", "");
IJ.run(nucleiImp, "Dilate", "");
IJ.run(nucleiImp, "Dilate", "");
IJ.run("Set Measurements...", "area centroid center bounding fit shape redirect=None decimal=2");
IJ.run(nucleiImp, "Analyze Particles...", "size=" + nMinSize + "-" + nMaxSize + 
							"  display exclude clear add");

// add nuclei to our list of nuclei:
res = ij.measure.ResultsTable.getResultsTable();
for (int i = 0; i < res.getCounter(); i++) {
  	p = new Point2D.Double(res.getValue("X", i),res.getValue("Y", i));
  	nuclei.add(p);
}

// run particle analyzer one more time, to include particles at the edge
// so that we will not confuse them with micronuclei
IJ.run(nucleiImp, "Analyze Particles...", "size=" + nMinSize + "-" + nMaxSize + 
							"  display clear add");

// close the ImagePlus we no longer need							
nucleiImp.changes = false;
nucleiImp.close();

// Use local maxima finder to find spots in the original image:
pol = FindLocalMaxima.FindMax(imp, 4, 1100, FindLocalMaxima.FilterType.GAUSSIAN1_5);

imp.close();
rm = RoiManager.getInstance2();
if (pol != null) {
	// gui.message("npoints: " + pol.npoints);
	for (i = 0; i < pol.npoints; i++) {
		x = pol.xpoints[i];
		y = pol.ypoints[i];
		//gui.message("spot " + x + ", " + y);
		inROI = false;
		for (roi : rm.getRoisAsArray()) {
			if (roi.contains(x, y)) {
				inROI = true;
			}
		}
		if (!inROI) {
			pt = new Point2D.Double( cal.getX(x),cal.getX(y) );
			if ( pt.x > minEdgeDistance && pt.y > minEdgeDistance &&
						pt.x < (widthUm - minEdgeDistance)  && 
						pt.y < (heightUm - minEdgeDistance) ) 
			{
  				microNuclei.add(pt);
			}
			// gui.message("spot " + x + ", " + y + " was not in an ROI");
		}
	}
}

// report what we found
res.reset();
// sanity checks:
if (microNuclei.size() < 20 && nuclei.size() > 5) {
	for (mn : microNuclei) {
		cn = closest(mn, nuclei);
		if (cn != null && 30 > distance(mn, cn) ) {
			res.incrementCounter();
			res.addValue("Pos", imp.getShortTitle());
			res.addValue("X", mn.x);
			res.addValue("Y", mn.y);
			res.addValue("nX", cn.x);
			res.addValue("nY", cn.y);
			res.addValue("distance", distance(mn, cn));
		} 
	}
}
res.show("Results");
